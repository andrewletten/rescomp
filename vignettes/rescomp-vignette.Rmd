---
title: "rescomp: An R package for efficient ODE modelling of resource competition"
author: "Andrew D. Letten"
output: 
#    html_document: default
    rmarkdown::pdf_document: default
#    number_sections: true
vignette: >
  %\VignetteIndexEntry{rescomp, how to...}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

`rescomp` is an R package for defining ode models of consumer-resource interactions for use alongside `deSolve`. It also provides a number of additional functions for visualising functional responses and output dynamics from `deSolve`.

The main user function in `rescomp` is `make_par_list()`, which facilitates the definition and parameterisation of a desired model. Features/options include: 

- Number of consumers/resources
- Consumer functional response (type I or type II)
- Resource dynamic (chemostat, logistic and/or pulsed)
- Resource type (substitutable or essential)
- Continuous or intermittent mortality (e.g. serial transfer)
- Time dependent consumption parameters 

See `?make_par_list` for all argument options.

**Examples demonstrated in this vignette include:**

- One type 2 consumer and one logistically growing resource
- One type 2 consumer and one continuously supplied resource (i.e. chemostat) 
- Two type 2 consumers and one logistically growing resource
- Two type 1 consumers and two substitutable resources in a chemostat
- Two type 1 consumers and two essential resources in a chemostat
- Two type 2 consumers and one externally pulsed resource 
    * Continuous mortality
    * Serial transfer in batch culture (intermittent mortality)
- Two type 2 consumers with time dependent consumption parameters and one continuously supplied resource
- Three type 1 consumers on three essential resources generating an intransitive loop (i.e. rock paper scissors dynamics). 


## Type 2 consumer on a logistically growing resource


```{r setup}
library(rescomp)
library(deSolve)
```

```{r}
pars <- make_par_list(
  spnum = 1, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(0.12)),
  resspeed = 3,
  resconc = 2
)
```

Visualise funcitonal responses with `rescomp::plot_funcresp`. Faceted by resources and time dependent parameterisations (when relevant).

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = 2)
```

The function `time_vals` is used for setting total simulation time (and is used to set the resource pulse interval when used in conjunction with an event function [see below]). The function `initiate_state` sets the starting values of state variables defaulting to 10 for consumers and the resource supply concentration for resources.

```{r}
happenings <- time_vals(total = 500)

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda"
  )
```

`plot_cr_sim` plots the output dynamics.

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

## Type 2 consumer on a continuously suppplied resource

To switch to a continuously supplied resource,use `chemo = TRUE'.

```{r}
pars <- make_par_list(
  spnum = 1, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(0.12)),
  resspeed = 3,
  resconc = 2,
  chemo = TRUE
)
```

```{r}
happenings <- time_vals(total = 500)

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda"
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

## Two type 2 consumers on a logistically growing resource

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.7,0.05), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE)),
  kmatrix = matrix(c(2, 0.015), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  
  resspeed = 3,
  resconc = 0.2
)
```

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = 0.2)
```

```{r}
happenings <- time_vals(total = 2000)

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda"
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

Owing to the trade-off in functional responses (gleaner-opportunist) and resource fluctuations generated by N2, the two consumers are able to coexist via the coexistence mechanism known as 'relative nonlinearity of competition'.

## Two type 1 consumers and two substitutable resources in a chemostat

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 2,
  linear = TRUE,
  mumatrix = list(matrix(c(0.07,0.03,
                           0.04,0.05), 
                    nrow = 2, 
                    ncol = 2,
                    byrow = TRUE)),
  resspeed = 3,
  resconc = 1,
  mort = 0.01,
  chemo = TRUE,
  essential = FALSE
)
```

```{r, fig.width = 6, fig.height = 3}
plot_funcresp(pars, maxx = 1)
```

```{r}
happenings <- time_vals(total = 1000)

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda"
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

Resource partitioning, where each consumer is a better competitor (lower R*) for a different resource, results in coexistence.

## Two type 1 consumers and two essential resources in a chemostat

Using `pars$essential = TRUE` switches the previous parameteristion to essential resources while keeping all else equal.

```{r}
pars$essential = TRUE

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda"
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```
There is no coexistence now because each species needs to have a larger impact on the resource that is most limiting its growth. For 'consumer 1' it is 'resource b', whereas for 'consumer 2' it is 'resource a'. We can adjust consumer resource impacts via the resource quota matrix.

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 2,
  linear = TRUE,
  mumatrix = list(matrix(c(0.07, 0.03,
                           0.04, 0.05), 
                    nrow = 2, 
                    ncol = 2,
                    byrow = TRUE)),
  qmatrix = matrix(c(0.001, 0.005,
                     0.005, 0.001),
                   nrow = 2,
                   ncol = 2,
                   byrow = TRUE),
  resspeed = 3,
  resconc = 1,
  mort = 0.01,
  chemo = TRUE,
  essential = TRUE
)
```


```{r}
m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda"
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```


## Two type 2 consumers and one externally pulsed resource (continuous mortality)

External resource pulsing is handled using an event function, `rescomp::eventfun_respulse`, which is passed in a list to `deSolve::ode`. The size of the resource pulse is specified as a numeric with the argument `respulse` in the call to `make_par_list`. To prevent any other mode of resource supply, `resspeed` should be set to zero. The frequency of pulsing is set with the `pulse` argument in `rescomp::time_vals`. The resultant vector of pusling intervals should be included in the same list containing the event function.

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.7,0.05), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE)),
  kmatrix = matrix(c(2, 0.015), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  
  resspeed = 0, # set to zero for no additional resource supply 
  resconc = 0.2,
  respulse = 0.3 # resource pulse size
)
```

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = max(pars$respulse))
```

```{r}
happenings <- time_vals(total = 2000, pulse = 100) # 'pulse' sets the interval 

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda",
  # events argument takes a list including the event function and a vector of pulsing intervals
  events = list(func = eventfun_respulse, time = happenings$pulseseq),
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

## Two type 2 consumers and one externally pulsed resource (serial transfer with pulsed mortality)

Serial transfer in batch culture differs from the above scenario in that resource pulses are typically accompanied by large instantaneous changes in population density. For an example, in a serial transfer experiment with bacteria, a researcher might sample a fraction (e.g. 10%) of the community every 24 hours and inoculate that fraction intro fresh media.   

Simulating serial transfer in batch culture is implemented by: 

  1. Using `batchtrans = TRUE` in `rescomp::make_par_list`. 
  2. Assigning a value from 0 to 1 for the argument `mortpulse`. This is the fraction of the consumer(s) population instantaneous 'killed' at set intervals. Note the transfer fraction = 1 - `mortpulse`.
  3. Setting the serial transfer schedule with the `pulse` argument in `rescomp::time_vals` (coincident with resource pulse intervals).
  
Note that the effect of setting `batchtrans = TRUE` is to enforce  fractional sampling of the resource/media in addition to the consumers. As such, immediately after a transfer event the resource concentration will be equal to: 

$$(1-m)R + mS,$$

where $m$ is given by `mortpulse` and therefore $1 - m$ equat es to the transfer fraction, $R$ is the resource concentration prior to transfer, and $S$ is the resource pulse size given by `respulse`. To inhibit the behavior, i.e to stop fractional sampling of the resource but maintain intermittent mortality use `batchtrans = FALSE` but still assign a non-zero value for `mortpulse`.    

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.2,0.2), 
                         nrow = 2, 
                         ncol = 1,
                         byrow = TRUE)),
  kmatrix = matrix(c(0.3, 0.2), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  
  chemo = TRUE,
  resspeed = 0, # set to zero for no additional resource supply 
  resconc = 0.6,
  respulse = 1,
  mort = 0, # set to zero to make the transfer fraction the effective mortality rate
  mortpulse = 0.8,
  batchtrans = TRUE
)
```

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = max(pars$respulse))
```

```{r}
happenings <- time_vals(total = 1000, pulse = 100) # pulse resource and mortality schedule

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(restart = 0.2, vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda",
  events = list(func = eventfun_respulse, time = happenings$pulseseq)
)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

Note, to reproduce the dynamics of a single batch culture experiment (i.e. without serial transfer) as potentially measured via optical density in a plate reader (negligible or unobservable mortality), simply set both `resspeed` and `mort` to zero. 

```{r}
pars <- make_par_list(resspeed = 0, mort = 0)
happenings <- time_vals(total = 500) 

testrun.df <- ode(
  func = def_cr_ode,
  y = initiate_state(restart = 0.2, vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda"
)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(testrun.df, pars) 
```

## Two type 2 consumers with time dependent consumption parameters and one continuously supplied resource

Using time dependent consumption parameters is appropriate for capturing basic consumer-environment interactions (e.g. differential responses to temperature, pH, antibiotics etc.). Time varying parameters can be implemented in `deSolve` with forcing functions. `rescomp` provides a straightforward means of implementing forcing functions in the background. Three additional arguments are needed in `make_par_list`: `timepars`, `timeswitch` and `time_switch_length`. `timepars` should be set to `TRUE`; `timeswitch` adjusts the frequency of switching between 'environmental states'; `time_switch_length` adjust the total time over which the environment varies (for most applications this should equal the total time in the call to `time_vals`). 

In addition, if `time_pars` = TRUE, the mumatrix argument `make_par_list` expects a list containing two matrices, reflecting two different environmental states. At this stage `rescomp` only handles two states with equal time allotted to each state.

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.3,0.1), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE),
                  matrix(c(0.2,0.5), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE)),
  kmatrix = matrix(c(0.1, 0.1), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  

  chemo = TRUE,
  resspeed = 0.1,
  resconc = 0.1,
  timepars = TRUE,
  timeswitch = 50,
  timeswitch_length = 2000
)
```

```{r, fig.width = 4, fig.height = 5}
plot_funcresp(pars, maxx = max(pars$resconc))
```

```{r}
happenings <- time_vals(total = 2000)

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda",
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

The two consumers coexist due species-specific environmental responses leading to a temporal storage effect (formalization of temporal niche paritioning arising from density dependence in environment-competition covariance).


## Three type 1 consumers on three essential resources generating an intransitive loop (i.e. rock paper scissors dynamics).

```{r}
pars <- make_par_list(
  spnum = 3, 
  resnum = 3,
  linear = TRUE,
  mumatrix = list(matrix(c(
    0.11, 0.07,  0.045,
    0.05, 0.11,  0.07,
    0.07, 0.047, 0.1
    ), 
    nrow = 3,
    ncol = 3,
    byrow = TRUE)),
  qmatrix = matrix(c(
    0.2, 0.7, 0.4,
    0.4, 0.2, 0.7,
    0.7, 0.4, 0.2
    ), 
    nrow = 3,
    ncol = 3,
    byrow = TRUE),
  essential = TRUE,  
  chemo = FALSE,
  mort = 0.015,
  resspeed = 10,
  resconc = 0.5
)
```

```{r, fig.width = 6, fig.height = 3}
plot_funcresp(pars, maxx = max(pars$resconc))
```

```{r}
happenings <- time_vals(total = 2000)

m1 <- ode(
  func = def_cr_ode,
  y = initiate_state(vars=pars),
  parms = pars,
  times = happenings$totaltime,
  method = "lsoda",
  )
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```
