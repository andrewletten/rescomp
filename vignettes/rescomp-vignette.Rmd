---
title: "rescomp: An R package for efficient ODE modelling of resource competition"
author: "Andrew D. Letten"
output: 
#    html_document: default
    rmarkdown::pdf_document: default
#    number_sections: true
vignette: >
  %\VignetteIndexEntry{rescomp, how to...}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

`rescomp` is an R package for generating, simulating and visualising ODE models of consumer-resource interactions. In essence, it is a consumer-resource modelling focused interface to the excellent `deSolve` package.

# Model formulation

All `rescomp` models take the general form,

$$
\frac{dN_{i}}{dt} = N_{i}(\mu_{i}(R_{1},R_{2},...)-m) \,,
$$

$$
\frac{dR_{j}}{dt} = \Psi_{j} (R_{j}) - \sum_{i = 1}^{n}Q_{ij} \mu_{ij}(R_j) N_i \,,
$$

where $N_{i}$ is the population density of consumer $i$, $R_{j}$ is the density/concentration of resource $j$, $\mu_{i}()$ is the per capita consumer functional response of consumer $i$, $m$ is the per capita mortality rate (constant or pulsed), $\Psi_{j}(R_j)$ is the resource supply function, and $Q_{ij}$ is the resource quota of consumer $i$ on resource $j$.  

From this general form, different model formulations are distinguished by: i) the number of consumers/resources; ii) the form of the consumer functional response; iii) the mode of resource supply; iv) the type of resource; and v) any non-autonomous behaviour including instantaneous changes in consumer/resource density and/or time dependent model parameters.

The consumer growth function can take one of three forms: 

i) linear (type I), 
 
$$
\mu_{ij}(R_{j}) = a_{ij}R_{j} \,,
$$
 
where $a_{ij}$ is a constant of proportionality; 

ii) nonlinear type II (aka Monod),
 
$$
\mu_{ij}(R_{j}) = \mu _{max_{ij}}\frac{R_{j}}{k_{ij} + R_{j}} \,,
$$
 
where $\mu_{max_{ij}}$ is the maximum growth rate and $k_{ij}$ is the half saturation constant for consumer $i$ on resource $j$; or 

iii) nonlinear type III,

$$
\mu_{ij}(R_{j}) = \mu _{max_{ij}}\frac{R_{j}^2}{k_{ij}^2 + R_{j}^2} \,.
$$

In all three cases, the functional response is either assumed to be constant or variable through time (the latter is mediated by time dependent formulations of $a_{ij}$ (type I) or $\mu_{max_{ij}}$ (type II & III).

The resource supply function, $\Psi_{j}(R_j)$, can also take several forms. Specifically, either the resources are biological and grow logistically,
 
$$
\Psi_{j} (R_{j}) = r_{j}R_{j}\left(1-\frac{R_{j}}{K_{j}}\right) \,,
$$
 
where $r_j$ is the resource intrinsic rate of increase and $K_j$ is the resource carrying capacity; 

Or the resources are supplied to the systems at a fixed concentration and rate (as in a chemostat),
 
$$
\Psi_{j} (R_{j}) = d(S_{j} - R_{j}) \,,
$$
 
where \textit{d} represents the flux of resources into and out of the system.

Or the resources are pulsed intermittently (see below).

In the case of multiple resources, each resource is either treated as essential to consumer growth following Leibig's law of the minimum, in which case,
 
$$
\mu_{i}(R_{1}, R_{2},...,R_{n}) = min(\mu_{i}(R_{1}), \mu_{i}(R_{2}),..., \mu_{i}(R_{n})) \,;
$$
 
or substitutable such that:
 
$$
\mu_{i}(R_{1}, R_{2},...,R_{n}) = \mu_{i}(R_{1}) + \mu_{i}(R_{2}) + ... + \mu_{i}(R_{n}) \,.
$$ 

The model specification also allows for instantaneous changes in consumer and resource state variables, e.g. in batch transfer (further details in examples below).

# Using `rescomp` 

The main user function in `rescomp` is `make_par_list()`, which facilitates the definition and parameterisation of a desired model and the specification of simulation parameters. Function arguments include (but are not limited to): 

- Number of consumers/resources
- Consumer functional response (type I, II or II)
- Resource dynamic (chemostat, logistic and/or pulsed)
- Resource type (substitutable or essential)
- Continuous or intermittent mortality (e.g. serial transfer)
- Time dependent consumption parameters 

See `?make_par_list` for all argument options.

**Examples demonstrated in this vignette include:**

- One type 2 consumer and one logistically growing resource
- One type 2 consumer and one continuously supplied resource (i.e. chemostat) 
- Two type 2 consumers and one logistically growing resource
- Two type 1 consumers and two substitutable resources in a chemostat
- Two type 1 consumers and two essential resources in a chemostat
- Two type 2 consumers and one externally pulsed resource 
    * Continuous mortality
    * Serial transfer in batch culture (intermittent mortality)
- Two type 2 consumers with time dependent consumption parameters and one continuously supplied resource
- Three type 1 consumers on three essential resources generating an intransitive loop (i.e. rock paper scissors dynamics). 


## Type 2 consumer on a logistically growing resource


```{r setup}
library(rescomp)
library(deSolve)
```

```{r}
pars <- make_par_list(
  spnum = 1, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(0.12)),
  resspeed = 3,
  resconc = 2,
  totaltime = 500
)
```

Visualise functional responses with `rescomp::plot_funcresp`. Faceted by resources and time dependent parameterisations (when relevant).

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = 2)
```

The model can then be simulated with `rescomp::sim_rescomp`. `sim_rescomp` is a wrapper to `deSolve::ode` that takes the output from `make_par_list` as its main argument.

```{r}
m1 <- sim_rescomp(pars)
```

`plot_cr_sim` plots the output dynamics.

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

<!-- The function `time_vals` is used for setting total simulation time (and is used to set the resource pulse interval when used in conjunction with an event function [see below]). The function `initiate_state` sets the starting values of state variables defaulting to 10 for consumers and the resource supply concentration for resources. -->


## Type 2 consumer on a continuously suppplied resource

To switch to a continuously supplied resource,use `chemo = TRUE'.

```{r}
pars <- make_par_list(
  spnum = 1, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(0.12)),
  resspeed = 3,
  resconc = 2,
  chemo = TRUE,
  totaltime = 500
)
```

```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

## Two type 2 consumers on a logistically growing resource

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.7,0.05), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE)),
  kmatrix = matrix(c(2, 0.015), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  
  resspeed = 3,
  resconc = 0.2,
  totaltime = 2000
)
```

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = 0.2)
```

```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

Owing to the trade-off in functional responses (gleaner-opportunist) and resource fluctuations generated by N2, the two consumers are able to coexist via the coexistence mechanism known as 'relative nonlinearity of competition'.

## Two type 1 consumers and two substitutable resources in a chemostat

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 2,
  linear = TRUE,
  mumatrix = list(matrix(c(0.07,0.03,
                           0.04,0.05), 
                    nrow = 2, 
                    ncol = 2,
                    byrow = TRUE)),
  resspeed = 3,
  resconc = 1,
  mort = 0.01,
  chemo = TRUE,
  essential = FALSE
)
```

```{r, fig.width = 6, fig.height = 3}
plot_funcresp(pars, maxx = 1)
```

```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

Resource partitioning, where each consumer is a better competitor (lower R*) for a different resource, results in coexistence.

## Two type 1 consumers and two essential resources in a chemostat

Using `pars$essential = TRUE` switches the previous parameteristion to essential resources while keeping all else equal.

```{r}
pars$essential = TRUE
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

There is no coexistence now because each species needs to have a larger impact on the resource that is most limiting its growth. For 'consumer 1' it is 'resource b', whereas for 'consumer 2' it is 'resource a'. We can adjust consumer resource impacts via the resource quota matrix.

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 2,
  linear = TRUE,
  mumatrix = list(matrix(c(0.07, 0.03,
                           0.04, 0.05), 
                    nrow = 2, 
                    ncol = 2,
                    byrow = TRUE)),
  qmatrix = matrix(c(0.001, 0.005,
                     0.005, 0.001),
                   nrow = 2,
                   ncol = 2,
                   byrow = TRUE),
  resspeed = 3,
  resconc = 1,
  mort = 0.01,
  chemo = TRUE,
  essential = TRUE
)
```


```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```


## Two type 2 consumers and one externally pulsed resource (continuous mortality)

External resource pulsing is handled using an event function, `rescomp::eventfun_respulse`, which is passed in a list to `deSolve::ode`. The size of the resource pulse is specified as a numeric with the argument `respulse` in the call to `make_par_list`. To prevent any other mode of resource supply, `resspeed` should be set to zero. The frequency of pulsing is set with the `pulse` argument in `rescomp::time_vals`. The resultant vector of pusling intervals should be included in the same list containing the event function.

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.7,0.05), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE)),
  kmatrix = matrix(c(2, 0.015), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  
  resspeed = 0, # set to zero for no additional resource supply 
  resconc = 0.2,
  respulse = 0.3,
  pulsefreq = 100# resource pulse size
)
```

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = max(pars$respulse))
```

```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

## Two type 2 consumers and one externally pulsed resource (serial transfer with pulsed mortality)

Serial transfer in batch culture differs from the above scenario in that resource pulses are typically accompanied by large instantaneous changes in population density. For an example, in a serial transfer experiment with bacteria, an experimenter might sample a fraction (e.g. 10%) of the community every 24 hours and inoculate that fraction intro fresh media. As such, the consumer population density immediately following a transfer event will be equal to: $(1-M)N_{i}$, where $M$ is instantaneous mortality fraction given by `mortpulse`.

Simulating serial transfer in batch culture is implemented by: 

  1. Using `batchtrans = TRUE` in `rescomp::make_par_list`. 
  2. Assigning a value from 0 to 1 for the argument `mortpulse`. This is the fraction of the consumer(s) population instantaneous 'killed' at set intervals. Note the transfer fraction = 1 - `mortpulse`.
  3. Setting the serial transfer schedule with the `pulse` argument in `rescomp::time_vals` (coincident with resource pulse intervals).
  
Note that the effect of setting `batchtrans = TRUE` is to enforce  fractional sampling of the resource/media in addition to the consumers. As such, immediately after a transfer event the resource concentration will be equal to: $(1-M)R_{j} + MS_{j}$, where $R$ is the resource concentration prior to transfer, and $S$ is the resource pulse size given by `respulse`. To inhibit the behaviour, i.e. to stop fractional sampling of the resource but maintain intermittent mortality use `batchtrans = FALSE` but still assign a non-zero value for `mortpulse`.    

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.2,0.2), 
                         nrow = 2, 
                         ncol = 1,
                         byrow = TRUE)),
  kmatrix = matrix(c(0.3, 0.2), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  
  chemo = TRUE,
  resspeed = 0, # set to zero for no additional resource supply 
  resconc = 0.6,
  respulse = 1,
  mort = 0, # set to zero to make the transfer fraction the effective mortality rate
  mortpulse = 0.8,
  batchtrans = TRUE,
  pulsefreq = 100,
)
```

```{r, fig.width = 4, fig.height = 3}
plot_funcresp(pars, maxx = max(pars$respulse))
```

```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

Note, to reproduce the dynamics of a single batch culture experiment (i.e. without serial transfer) as potentially measured via optical density in a plate reader (negligible or unobserved mortality), simply set both `resspeed` and `mort` to zero. 

```{r}
pars <- make_par_list(resspeed = 0, mort = 0, totaltime = 500)
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

## Two type 2 consumers with time dependent consumption parameters and one continuously supplied resource

Using time dependent consumption parameters is appropriate for capturing basic consumer-environment interactions (e.g. differential responses to temperature, pH, antibiotics etc.). Time varying parameters can be implemented in `deSolve` with forcing functions. `rescomp` provides a convenient means of implementing forcing functions in the background. Two additional arguments are needed in `make_par_list`: `timepars` and `timeparfreq`. `timepars` should be set to `TRUE`; `timeparfreq` adjusts the frequency of switching between 'environmental states'.

In addition, if `time_pars = TRUE`, the mumatrix argument in `make_par_list` expects a list containing two matrices, reflecting two different environmental states. At this stage `rescomp` only handles two states with equal time allotted to each state. 

<!-- or a linear transition between states -->

```{r}
pars <- make_par_list(
  spnum = 2, 
  resnum = 1,
  linear = FALSE,
  mumatrix = list(matrix(c(0.3,0.1), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE),
                  matrix(c(0.2,0.5), 
                    nrow = 2, 
                    ncol = 1,
                    byrow = TRUE)),
  kmatrix = matrix(c(0.1, 0.1), 
                   nrow = 2, 
                   ncol = 1, 
                   byrow = TRUE),  

  chemo = TRUE,
  resspeed = 0.1,
  resconc = 0.1,
  timepars = TRUE,
  timeparfreq = 50,
  totaltime = 2000
)
```

```{r, fig.width = 4, fig.height = 5}
plot_funcresp(pars, maxx = max(pars$resconc))
```

```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```

The two consumers coexist due species-specific environmental responses leading to a temporal storage effect (formalization of temporal niche paritioning arising from density dependence in environment-competition covariance) (ref).


## Three type 1 consumers on three essential resources generating an intransitive loop (i.e. rock paper scissors dynamics).

```{r}
pars <- make_par_list(
  spnum = 3, 
  resnum = 3,
  linear = TRUE,
  mumatrix = list(matrix(c(
    0.11, 0.07,  0.045,
    0.05, 0.11,  0.07,
    0.07, 0.047, 0.1
    ), 
    nrow = 3,
    ncol = 3,
    byrow = TRUE)),
  qmatrix = matrix(c(
    0.2, 0.7, 0.4,
    0.4, 0.2, 0.7,
    0.7, 0.4, 0.2
    ), 
    nrow = 3,
    ncol = 3,
    byrow = TRUE),
  essential = TRUE,  
  chemo = FALSE,
  mort = 0.015,
  resspeed = 10,
  resconc = 0.5,
  totaltime = 2000
)
```

```{r, fig.width = 6, fig.height = 3}
plot_funcresp(pars, maxx = max(pars$resconc))
```

```{r}
m1 <- sim_rescomp(pars)
```

```{r, fig.width = 6, fig.height = 3}
plot_crsim(m1, pars) 
```
